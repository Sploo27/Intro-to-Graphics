
// using color = vec3;
#define colorRGB    vec3;
#define colorRGBA   vec4;

vec4 myEffect0(in vec2 fragCoord)
{
    
    
    vec2 uv = fragCoord / iResolution.xy;
    
    //vec3 color = vec3(uv, 0.0);
    vec3 color = 0.5 + 0.5*sin(iTime+uv.yxy+vec3(2,4,6));
	
    float alpha = 1.0;
    
    //return vec4(1.0, 0.5, 0.0, 1.0);	
    return vec4(color, alpha);
    
}

float circle(float radius, vec2 center, vec2 uv) {
	float d = distance(center, uv);
    return 1.0 - step(radius, d);
}

float makeCheckerboard(vec2 fragCoord)
{
    float tileSize = 10.0; // controls the amount of pixels per block
	float tileNumber = 10.0;
	float modNum = 1.5;
	
    
    vec2 uv = fragCoord/iResolution.xy;
	vec2 tile = floor(fragCoord / tileSize);		// Controls the size of the tile
    float pattern = mod(tile.x + tile.y, modNum);		// Controls the actual pattern displayed
    return pattern;
}


vec4 movement(vec2 fragCoord)
{
    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;
    
	float radius = 0.1;
    float speed = 2.0;
    
    
    vec2 center = vec2(sin(iTime * speed) / 2.0, cos(iTime * speed) / 4.0);  //ellipse that the circle moves around
    float c = circle(radius * (sin(iTime) + 1.0), center, uv);
    
    
    vec3 col = vec3(c);
    return vec4(col, 1.0);
}


void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    //fragColor = makeCheckerboard(fragCoord) * myEffect0(fragCoord);  //creates a checkerboard over
    
    fragColor = makeCheckerboard(fragCoord) * myEffect0(fragCoord) + (movement(fragCoord) * myEffect0(fragCoord*2.0));
}